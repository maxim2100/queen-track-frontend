name: CI/CD Pipeline

on:
  push:
    branches: [main, stage]
  pull_request:
    branches: [main, stage]
  workflow_dispatch:
    inputs:
      deployment_target:
        description: "Choose deployment target"
        required: true
        default: "staging"
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: "Skip tests (for emergency deployments)"
        required: false
        default: false
        type: boolean

env:
  NODE_VERSION: "18"
  PRODUCTION_DOMAIN: "queentrack.online"

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    if: github.event_name != 'workflow_dispatch' || inputs.skip_tests != true

    steps:
      - name: Show manual trigger details
        if: github.event_name == 'workflow_dispatch'
        run: |
          echo "🔧 Manual deployment triggered"
          echo "Target: ${{ inputs.deployment_target }}"
          echo "Skip tests: ${{ inputs.skip_tests }}"
          echo "Triggered by: ${{ github.actor }}"

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm install --legacy-peer-deps

      - name: Run ESLint
        run: npm run lint
        continue-on-error: true

      - name: Run tests with coverage
        run: npm run test:ci
        continue-on-error: true

      - name: Upload coverage reports
        uses: codecov/codecov-action@v3
        if: always()
        with:
          file: ./coverage/lcov.info
          fail_ci_if_error: false

      - name: Store test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: |
            coverage/
            test-results.xml

  build-staging:
    name: Build for Staging
    runs-on: ubuntu-latest
    needs: test
    if: |
      always() && 
      (github.ref == 'refs/heads/stage' || 
       (github.event_name == 'workflow_dispatch' && inputs.deployment_target == 'staging')) &&
      (needs.test.result == 'success' || needs.test.result == 'skipped')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm install --legacy-peer-deps

      - name: Copy staging environment file
        run: cp .env.staging .env

      - name: Build application for staging
        run: npm run build:staging

      - name: Run build tests
        run: |
          # Test that build directory exists and contains expected files
          test -d build
          test -f build/index.html
          test -f build/static/js/main.*.js || test -f build/static/js/*.js
          test -f build/static/css/main.*.css || test -f build/static/css/*.css

      - name: Store staging build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-staging
          path: build/
          retention-days: 7

  build-production:
    name: Build for Production
    runs-on: ubuntu-latest
    needs: test
    if: |
      always() && 
      (github.ref == 'refs/heads/main' || 
       (github.event_name == 'workflow_dispatch' && inputs.deployment_target == 'production')) &&
      (needs.test.result == 'success' || needs.test.result == 'skipped')

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: "npm"

      - name: Install dependencies
        run: npm install --legacy-peer-deps

      - name: Copy production environment file
        run: cp .env.production .env

      - name: Build application for production
        run: npm run build:production

      - name: Run build tests
        run: |
          # Test that build directory exists and contains expected files
          test -d build
          test -f build/index.html
          test -f build/static/js/main.*.js || test -f build/static/js/*.js
          test -f build/static/css/main.*.css || test -f build/static/css/*.css

      - name: Store production build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: build-production
          path: build/
          retention-days: 7

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build-staging]
    if: |
      github.ref == 'refs/heads/stage' || 
      (github.event_name == 'workflow_dispatch' && inputs.deployment_target == 'staging')
    environment: staging
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-staging
          path: build/

      - name: Install sshpass
        run: sudo apt-get update && sudo apt-get install -y sshpass

      - name: Deploy to staging server
        env:
          SERVER_HOST: "162.55.53.52"
          SERVER_USER: "root"
          SERVER_PASSWORD: ${{ secrets.SERVER_PASSWORD }}
          SERVER_PORT: "3002"
          SERVER_PATH: "/var/www/queen-track-staging"
        run: |
          echo "Deploying to staging server..."

          # Create deployment package
          TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
          PACKAGE_NAME="queen-track-frontend-staging-$TIMESTAMP.tar.gz"
          tar -czf "$PACKAGE_NAME" -C build .

          # Upload and deploy
          sshpass -p "$SERVER_PASSWORD" scp -o StrictHostKeyChecking=no "$PACKAGE_NAME" "$SERVER_USER@$SERVER_HOST:/tmp/"

          sshpass -p "$SERVER_PASSWORD" ssh -o StrictHostKeyChecking=no "$SERVER_USER@$SERVER_HOST" << EOF
          set -e

          # Install and setup Nginx if not already installed
          if ! command -v nginx &> /dev/null; then
            echo "Installing Nginx..."
            apt update
            apt install -y nginx
          fi

          # Start and enable Nginx
          systemctl start nginx || service nginx start
          systemctl enable nginx || true

          # Create backup
          if [ -d "/var/www/queen-track-staging" ]; then
            cp -r "/var/www/queen-track-staging" "/var/www/queen-track-staging.backup.$TIMESTAMP"
          fi

          # Deploy new version
          mkdir -p "/var/www/queen-track-staging"
          cd /tmp
          tar -xzf "$PACKAGE_NAME" -C "/var/www/queen-track-staging"
          chown -R www-data:www-data "/var/www/queen-track-staging" 2>/dev/null || chown -R root:root "/var/www/queen-track-staging"
          chmod -R 755 "/var/www/queen-track-staging"

          # Ensure Nginx directories exist
          mkdir -p /etc/nginx/sites-available
          mkdir -p /etc/nginx/sites-enabled

          # Stop nginx to avoid configuration conflicts
          systemctl stop nginx || service nginx stop || true

          # Remove any existing conflicting configurations
          rm -f /etc/nginx/sites-enabled/queentrack.online
          rm -f /etc/nginx/sites-enabled/default
          rm -f /etc/nginx/sites-available/queentrack.online

          # Create a clean default nginx configuration to avoid SSL errors
            cat > /etc/nginx/nginx.conf << 'MAIN_NGINX_EOF'
          user www-data;
          worker_processes auto;
          pid /run/nginx.pid;
          include /etc/nginx/modules-enabled/*.conf;

          events {
              worker_connections 768;
          }

          http {
              sendfile on;
              tcp_nopush on;
              tcp_nodelay on;
              keepalive_timeout 65;
              types_hash_max_size 2048;

              include /etc/nginx/mime.types;
              default_type application/octet-stream;

              access_log /var/log/nginx/access.log;
              error_log /var/log/nginx/error.log;

              gzip on;

              include /etc/nginx/conf.d/*.conf;
              include /etc/nginx/sites-enabled/*;
          }
          MAIN_NGINX_EOF

          # Configure Nginx
            cat > /etc/nginx/sites-available/queen-track-staging << 'NGINX_EOF'
          # Define connection upgrade mapping
          map \$http_upgrade \$connection_upgrade {
              default upgrade;
              '' close;
          }

          server {
              listen 3002;
              server_name 162.55.53.52;
              root /var/www/queen-track-staging;
              index index.html;

              # Health check endpoint
              location /health {
                  return 200 "healthy\n";
                  add_header Content-Type text/plain;
              }

              # Static assets - serve directly
              location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
                  expires 1y;
                  add_header Cache-Control "public, immutable";
                  try_files \$uri =404;
              }

              # API and Video Routes proxy (including WebSockets)
              location ~ ^/(api|video)/ {
                  proxy_pass http://162.55.53.52:8000;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade \$connection_upgrade;
                  proxy_set_header Connection \$connection_upgrade;
                  proxy_set_header Host \$host;
                  proxy_set_header X-Real-IP \$remote_addr;
                  proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto \$scheme;
                  proxy_read_timeout 86400;
                  proxy_send_timeout 86400;
                  proxy_connect_timeout 5s;
              }

              # React Router - catch all other requests
              location / {
                  try_files \$uri \$uri/ @fallback;
              }

              # Fallback for React Router
              location @fallback {
                  rewrite ^.*\$ /index.html last;
              }

              # Gzip compression
              gzip on;
              gzip_vary on;
              gzip_min_length 1024;
              gzip_types text/plain text/css application/json application/javascript text/xml application/xml text/javascript;
          }
          NGINX_EOF
            
                      ln -sf /etc/nginx/sites-available/queen-track-staging /etc/nginx/sites-enabled/

          # Test Nginx configuration
          nginx -t
          if [ $? -ne 0 ]; then
            echo "❌ Nginx configuration test failed!"
            exit 1
          fi

          # Start Nginx with new configuration
          systemctl start nginx || service nginx start
          systemctl reload nginx || service nginx reload
          sleep 2

          # Verify Nginx is running and listening on port 3002
          echo "🔍 Checking Nginx status..."
          systemctl status nginx --no-pager || service nginx status

          echo "🔍 Checking if port 3002 is listening..."
          netstat -tlnp | grep :3002 || ss -tlnp | grep :3002

                    echo "🔍 Testing local connection..."
          curl -f http://localhost:3002/health || echo "❌ Local health check failed"

          # Check firewall and open port 3002 if needed
          echo "🔧 Configuring firewall for port 3002..."
          ufw allow 3002/tcp || iptables -I INPUT -p tcp --dport 3002 -j ACCEPT || echo "Firewall configuration failed"

          # Verify Nginx is actually serving on all interfaces
          echo "🔍 Checking Nginx listen configuration..."
          nginx -T | grep -A 5 -B 5 "listen 3002" || echo "No listen 3002 found in config"

          # Check what's actually listening on the port
          echo "🔍 Final port check..."
          netstat -tulnp | grep :3002 || ss -tulnp | grep :3002 || echo "Port 3002 not listening"

          # Clean up
          rm -f "/tmp/$PACKAGE_NAME"
          EOF

      - name: Run smoke tests
        run: |
          echo "🧪 Running smoke tests on staging..."

          # Wait for service to be ready
          echo "⏳ Waiting for service to start..."
          sleep 30

          # Test health endpoint with timeout and retries
          echo "🏥 Testing health endpoint..."
          for i in {1..5}; do
            if curl -f --connect-timeout 10 --max-time 30 http://162.55.53.52:3002/health; then
              echo "✅ Health check passed on attempt $i"
              break
            else
              echo "❌ Health check failed on attempt $i"
              if [ $i -eq 5 ]; then
                echo "🔍 Checking if port is open..."
                nmap -p 3002 162.55.53.52 || echo "nmap not available"
                exit 1
              fi
              sleep 10
            fi
          done

          # Test main page
          echo "🌐 Testing main page..."
          curl -f --connect-timeout 10 --max-time 30 http://162.55.53.52:3002/ >/dev/null 2>&1 || {
            echo "❌ Main page test failed"
            exit 1
          }

          echo "✅ All smoke tests passed!"

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-production]
    if: |
      github.ref == 'refs/heads/main' || 
      (github.event_name == 'workflow_dispatch' && inputs.deployment_target == 'production')
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-production
          path: build/

      - name: Install sshpass
        run: sudo apt-get update && sudo apt-get install -y sshpass

      - name: Deploy to production server
        env:
          SERVER_HOST: "162.55.53.52"
          SERVER_USER: "root"
          SERVER_PASSWORD: ${{ secrets.SERVER_PASSWORD }}
          SERVER_PORT: "80"
          SERVER_PATH: "/var/www/queentrack.online"
        run: |
          echo "Deploying to production server with HTTPS..."

          # Create deployment package
          TIMESTAMP=$(date +"%Y%m%d_%H%M%S")
          PACKAGE_NAME="queen-track-frontend-production-$TIMESTAMP.tar.gz"
          tar -czf "$PACKAGE_NAME" -C build .

          # Upload and deploy
          sshpass -p "$SERVER_PASSWORD" scp -o StrictHostKeyChecking=no "$PACKAGE_NAME" "$SERVER_USER@$SERVER_HOST:/tmp/"

          sshpass -p "$SERVER_PASSWORD" ssh -o StrictHostKeyChecking=no "$SERVER_USER@$SERVER_HOST" << 'EOF'
          set -e

          # Install required packages
          apt update
          apt install -y nginx certbot python3-certbot-nginx ufw dnsutils curl

          # Start and enable Nginx
          systemctl start nginx || service nginx start
          systemctl enable nginx || true

          # Create backup
          if [ -d "$SERVER_PATH" ]; then
            cp -r "$SERVER_PATH" "$SERVER_PATH.backup.$TIMESTAMP"
          fi

          # Deploy new version
          mkdir -p "$SERVER_PATH"
          cd /tmp
          tar -xzf "$PACKAGE_NAME" -C "$SERVER_PATH"
          chown -R www-data:www-data "$SERVER_PATH" 2>/dev/null || chown -R root:root "$SERVER_PATH"
          chmod -R 755 "$SERVER_PATH"

          # Ensure Nginx directories exist
          mkdir -p /etc/nginx/sites-available
          mkdir -p /etc/nginx/sites-enabled
          mkdir -p /var/www/html/.well-known/acme-challenge
          chown -R www-data:www-data /var/www/html/.well-known 2>/dev/null || chown -R root:root /var/www/html/.well-known

          # Stop nginx to avoid configuration conflicts
          systemctl stop nginx || service nginx stop || true

          # Remove any existing conflicting configurations
          rm -f /etc/nginx/sites-enabled/queen-track-staging
          rm -f /etc/nginx/sites-enabled/default

          # Create a clean default nginx configuration
          cat > /etc/nginx/nginx.conf << 'MAIN_NGINX_EOF'
          user www-data;
          worker_processes auto;
          pid /run/nginx.pid;
          include /etc/nginx/modules-enabled/*.conf;

          events {
              worker_connections 768;
          }

          http {
              sendfile on;
              tcp_nopush on;
              tcp_nodelay on;
              keepalive_timeout 65;
              types_hash_max_size 2048;

              include /etc/nginx/mime.types;
              default_type application/octet-stream;

              access_log /var/log/nginx/access.log;
              error_log /var/log/nginx/error.log;

              gzip on;

              include /etc/nginx/conf.d/*.conf;
              include /etc/nginx/sites-enabled/*;
          }
          MAIN_NGINX_EOF

          # Create complete nginx configuration with both HTTP and HTTPS
          cat > /etc/nginx/sites-available/queentrack.online << 'NGINX_EOF'
          # Define connection upgrade mapping
          map $http_upgrade $connection_upgrade {
              default upgrade;
              '' close;
          }

          # HTTP server - redirect to HTTPS
          server {
              listen 80;
              server_name queentrack.online www.queentrack.online;
              
              # ACME challenge for Let's Encrypt
              location /.well-known/acme-challenge/ {
                  root /var/www/html;
                  try_files $uri =404;
              }
              
              # Redirect all other traffic to HTTPS
              location / {
                  return 301 https://$server_name$request_uri;
              }
          }

          # HTTPS server
          server {
              listen 443 ssl http2;
              server_name queentrack.online www.queentrack.online;
              root $SERVER_PATH;
              index index.html;

              # SSL Configuration
              ssl_certificate /etc/letsencrypt/live/queentrack.online/fullchain.pem;
              ssl_certificate_key /etc/letsencrypt/live/queentrack.online/privkey.pem;
              
              # Modern SSL configuration
              ssl_protocols TLSv1.2 TLSv1.3;
              ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!3DES:!MD5:!PSK;
              ssl_prefer_server_ciphers off;
              
              # SSL session cache
              ssl_session_cache shared:SSL:50m;
              ssl_session_timeout 1d;
              ssl_session_tickets off;
              
              # HSTS
              add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;

              # Health check endpoint
              location /health {
                  return 200 "healthy\n";
                  add_header Content-Type text/plain;
              }

              # Static assets - serve directly with proper caching
              location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
                  expires 1y;
                  add_header Cache-Control "public, immutable";
                  try_files $uri =404;
              }

              # API and Video Routes proxy (including WebSockets)
              location ~ ^/(api|video)/ {
                  proxy_pass http://162.55.53.52:8000;
                  proxy_http_version 1.1;
                  proxy_set_header Upgrade $http_upgrade;
                  proxy_set_header Connection $connection_upgrade;
                  proxy_set_header Host $host;
                  proxy_set_header X-Real-IP $remote_addr;
                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
                  proxy_set_header X-Forwarded-Proto $scheme;
                  proxy_read_timeout 86400;
                  proxy_send_timeout 86400;
                  proxy_connect_timeout 5s;
              }

              # React Router - catch all other requests
              location / {
                  try_files $uri $uri/ @fallback;
              }

              # Fallback for React Router
              location @fallback {
                  rewrite ^.*$ /index.html last;
              }

              # Gzip compression
              gzip on;
              gzip_vary on;
              gzip_min_length 1024;
              gzip_proxied expired no-cache no-store private auth;
              gzip_types text/plain text/css application/json application/javascript text/xml application/xml text/javascript;
          }
          NGINX_EOF

          ln -sf /etc/nginx/sites-available/queentrack.online /etc/nginx/sites-enabled/

          # Configure firewall
          ufw allow 'Nginx Full' || true
          ufw allow 22 || true
          ufw allow 443/tcp || true
          ufw --force enable || true

          # Test Nginx configuration
          echo "Testing nginx configuration..."
          nginx -t
          if [ $? -ne 0 ]; then
            echo "❌ Nginx configuration test failed!"
            exit 1
          fi

          # Start Nginx with new configuration
          systemctl start nginx || service nginx start
          systemctl reload nginx || service nginx reload

          # Wait for nginx to start
          sleep 3

          # Check if SSL certificate exists and is valid
          if [ -f "/etc/letsencrypt/live/queentrack.online/fullchain.pem" ]; then
            echo "✅ SSL certificate found"
            
            # Verify SSL certificate validity
            if openssl x509 -checkend 86400 -noout -in /etc/letsencrypt/live/queentrack.online/fullchain.pem; then
              echo "✅ SSL certificate is valid"
            else
              echo "⚠️ SSL certificate is expiring soon or invalid"
            fi
          else
            echo "❌ SSL certificate not found!"
            exit 1
          fi

          # Verify nginx is running and listening on both ports
          echo "🔍 Checking nginx status..."
          systemctl status nginx --no-pager || service nginx status

          echo "🔍 Checking listening ports..."
          netstat -tlnp | grep nginx

          echo "🔍 Testing local HTTP connection..."
          curl -f http://localhost/health || echo "❌ Local HTTP health check failed"

          echo "🔍 Testing local HTTPS connection..."
          curl -f -k https://localhost/health || echo "❌ Local HTTPS health check failed"

          # Test SSL configuration
          echo "🔍 Testing SSL configuration..."
          echo | openssl s_client -connect localhost:443 -servername queentrack.online 2>/dev/null | openssl x509 -noout -subject || echo "❌ SSL connection test failed"

          # Clean up
          rm -f "/tmp/$PACKAGE_NAME"
          EOF

      - name: Run production smoke tests
        run: |
          echo "🧪 Running smoke tests on production..."

          # Wait for service to be ready
          echo "⏳ Waiting for service to start..."
          sleep 15

          # Test HTTPS health endpoint with retries
          echo "🏥 Testing HTTPS health endpoint..."
          for i in {1..6}; do
            echo "Attempt $i/6..."
            if curl -f --connect-timeout 15 --max-time 30 --retry 2 https://queentrack.online/health; then
              echo "✅ HTTPS health check passed on attempt $i"
              break
            else
              echo "❌ HTTPS health check failed on attempt $i"
              if [ $i -eq 6 ]; then
                echo "🔍 Final diagnostics..."
                # Test if port 443 is reachable
                nc -z -v queentrack.online 443 || echo "Port 443 is not reachable"
                # Test SSL certificate from outside
                echo | openssl s_client -connect queentrack.online:443 -servername queentrack.online 2>/dev/null | openssl x509 -noout -subject || echo "SSL certificate check failed"
                exit 1
              fi
              sleep 15
            fi
          done

          # Test HTTP to HTTPS redirect
          echo "🔄 Testing HTTP to HTTPS redirect..."
          HTTP_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" --max-time 20 http://queentrack.online/health)
          if [ "$HTTP_RESPONSE" = "301" ] || [ "$HTTP_RESPONSE" = "302" ]; then
            echo "✅ HTTP to HTTPS redirect working (response: $HTTP_RESPONSE)"
          else
            echo "⚠️ HTTP to HTTPS redirect may not be working properly (response: $HTTP_RESPONSE)"
          fi

          # Test main HTTPS page
          echo "🌐 Testing main HTTPS page..."
          curl -f --connect-timeout 15 --max-time 30 https://queentrack.online/ >/dev/null 2>&1 || {
            echo "❌ Main HTTPS page test failed"
            exit 1
          }

          # Test WWW redirect
          echo "🔄 Testing WWW redirect..."
          curl -f --connect-timeout 15 --max-time 30 https://www.queentrack.online/health >/dev/null 2>&1 || {
            echo "⚠️ WWW redirect test failed"
          }

          echo "✅ All production smoke tests passed!"

      - name: Notify deployment success
        if: success()
        run: |
          echo "✅ Production deployment successful!"
          echo "🌐 Application URL: https://queentrack.online"
          echo "🔒 SSL Certificate: Configured and working"
          echo "📊 Health Check: https://queentrack.online/health"
          echo "🔄 HTTP Redirect: All HTTP traffic redirected to HTTPS"

      - name: Notify deployment failure
        if: failure()
        run: |
          echo "❌ Production deployment failed!"
          echo "Please check the logs and SSL certificate configuration."
          echo "You may need to manually verify the nginx configuration on the server."
